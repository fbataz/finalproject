import threading # Module to help our game run different tasks at the same time (ie. timer)
import time # Will help us run our timer and suspend further lines of code while timer is running
import sys # 
import random # Module helps perform randomization procedures such as randomizing the question order for our game

questions = [
    ("Glycolysis", "What is the starting molecule of glycolysis?", "Glucose", 100),
    ("Glycolysis", "What is the end product of glycolysis under aerobic conditions?", "Pyruvate", 200),
    ("Glycolysis", "What molecule is produced as an energy currency during glycolysis?", "ATP", 100),
    ("Glycolysis", "What reducing agent is generated during glycolysis?", "NADH", 300),
    ("Krebs Cycle", "What molecule initiates the Krebs cycle by reacting with oxaloacetate?", "Acetyl-CoA", 200),
    ("Krebs Cycle", "Which molecule is a six-carbon compound that starts the Krebs cycle?", "Citrate", 300),
    ("Krebs Cycle", "What is the direct source of GTP production in the Krebs cycle?", "Succinate", 300),
    ("Pentose Phosphate Pathway", "What is the five-carbon sugar produced in the pentose phosphate pathway?", "Ribose", 200),
    ("Pentose Phosphate Pathway", "Which molecule provides reducing power for biosynthetic reactions in the pentose phosphate pathway?", "NADPH", 200),
    ("Calvin Cycle", "What molecule is regenerated at the end of the Calvin cycle to facilitate the cycle's continuation?", "RuBP", 300),
    ("Calvin Cycle", "During the Calvin cycle, what three-carbon molecule is produced that can be used to form glucose?", "G3P", 200),
    ("Electron Transport Chain", "What is the final electron acceptor in the electron transport chain?", "Oxygen", 100),
    ("Electron Transport Chain", "What molecule is produced as a by-product of oxygen accepting electrons in the ETC?", "Water", 200),
    ("Fatty Acid Synthesis", "What two-carbon molecule is the building block for fatty acid synthesis?", "Acetyl-CoA", 200),
    ("Fatty Acid Synthesis", "What is the end product of fatty acid synthesis that consists of 16 carbon atoms?", "Palmitate", 200),
    ("Fatty Acid Oxidation", "During beta-oxidation, what molecule is repeatedly cleaved off from fatty acids?", "Acetyl-CoA", 100),
    ("Amino Acid Metabolism", "Which amino acid serves as a key nitrogen donor in the synthesis of other amino acids?", "Glutamate", 100),
    ("Amino Acid Metabolism", "What is the main nitrogenous waste product in humans that is formed from ammonia?", "Urea", 100),
    ("Urea Cycle", "What is the final product of the urea cycle, which is excreted in urine?", "Urea", 100),
    ("Nucleotide Synthesis", "What is the precursor molecule to both adenine and guanine nucleotides?", "IMP", 100),
]

class Player: # Defining Player class
    def __init__(self, name):
        self.name = name # Assigns the name given to each player class
        self.score = 0 # Initializes player scores to 0 when a Player class is made

    def update_score(self, points): # Method updates player score
        self.score += points

class JeopardyGame:
    def __init__(self, questions):
    """
    Method to help initialize the questions that will be used for each round of the game.

    :param questions: tuple containing questions, with category, answer, and point data associated with each question. 
    """
        self.players = [] # Initializes an empty list that will include the players in the game
        self.questions = list(questions)  # Makes a copy of the questions
        self.time_limit = 10  # Adds time limit to questions
        random.shuffle(self.questions)  # Shuffle questions

    def add_player(self, name): # Method adds players to the game we are initializing
        self.players.append(Player(name)) # Appends empty list to include players specified

    def start(self): # Method to start the game and get it running
        question_index = 0  # Tracks the current question index
        total_questions = len(self.questions) # Assigns an integer value to total_questions that corresponds to the length of the self.questions list
        
        while question_index < total_questions:
            for player in self.players:
                if question_index >= total_questions:
                    break  # Break if no more questions are left
                if self.ask_question(self.questions[question_index], player): #calls asks question method, passing current question
                    return # Allows for player to quit the game
                question_index += 1

        self.rank_players()

    def ask_question(self, question, player): 
        """
        Method of JeopardyGame class:
        Asks a question to the player, will take their input and update their score
        :param question: a question from the question bank
        :param player: the player currently playing the round
        """
        category, text, answer, points = question
        print(f"\n{player.name}, Category: {category}, Points: {points}")
        print(text)
        
        answered = [False]
        def timer():
            for i in range(self.time_limit, 0, -1):
                if answered[0]:
                    return
                sys.stdout.write(f"\rTime remaining: {i} seconds ")
                sys.stdout.flush()
                time.sleep(1)
            if not answered[0]:
                print("Time's up!")
        
        timer_thread = threading.Thread(target=timer)
        timer_thread.start()
        player_answer = input("\nYour answer: ").strip()
        answered[0] = True
        
        if player_answer.lower() == 'quit': 
            print ("Quitting the game. Thanks for playing!")
            return True 
        if player_answer.lower() == answer.lower(): #checks to see if players answer matches correct answer (ignores case)
            player.update_score(points) #updates the point associated with question to players total points
            print("Correct!")
        else:
            print("Incorrect.")

    def rank_players(self): # Method that will rank players based on their final score
        print("Game Over. Final rankings:")
        sorted_players = sorted(self.players, key=lambda x: x.score, reverse=True) #creates new list and sorts players based on scores, ranking highest to lowest
        for index, player in enumerate(sorted_players, start=1):
            print(f"{index}. {player.name}: {player.score}")


